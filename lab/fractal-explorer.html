<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fractal Explorer ‚Äî M√óM Lab</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0a0f;
            color: #e0e0e0;
            font-family: 'Space Grotesk', sans-serif;
            overflow: hidden;
            height: 100vh;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            cursor: crosshair;
        }

        /* Controls panel */
        .controls {
            position: fixed;
            top: 16px;
            right: 16px;
            background: rgba(10, 10, 15, 0.92);
            border: 1px solid rgba(255,255,255,0.08);
            border-radius: 12px;
            padding: 20px;
            width: 280px;
            backdrop-filter: blur(20px);
            z-index: 10;
            font-size: 13px;
            transition: transform 0.3s ease;
        }
        .controls.hidden {
            transform: translateX(320px);
        }
        .controls h3 {
            font-size: 15px;
            margin-bottom: 12px;
            color: #fff;
            font-weight: 600;
        }
        .control-group {
            margin-bottom: 12px;
        }
        .control-group label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
            color: #888;
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
        }
        .control-group label span {
            color: #c8f;
        }
        input[type="range"] {
            width: 100%;
            height: 4px;
            -webkit-appearance: none;
            background: rgba(255,255,255,0.1);
            border-radius: 2px;
            outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #c8f;
            cursor: pointer;
        }
        select, button {
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            background: rgba(255,255,255,0.06);
            border: 1px solid rgba(255,255,255,0.1);
            color: #e0e0e0;
            border-radius: 6px;
            padding: 6px 10px;
            cursor: pointer;
            outline: none;
        }
        select { width: 100%; }
        .btn-row {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }
        .btn-row button { flex: 1; }
        button:hover { background: rgba(204, 136, 255, 0.15); border-color: #c8f; }

        /* Info bar */
        .info {
            position: fixed;
            bottom: 16px;
            left: 16px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            color: #666;
            z-index: 10;
            line-height: 1.6;
        }
        .info span { color: #888; }

        /* Back link */
        .back {
            position: fixed;
            top: 16px;
            left: 16px;
            color: #888;
            text-decoration: none;
            font-size: 13px;
            z-index: 10;
            transition: color 0.2s;
        }
        .back:hover { color: #c8f; }

        /* Toggle button */
        .toggle-panel {
            position: fixed;
            top: 16px;
            right: 16px;
            z-index: 11;
            background: rgba(10,10,15,0.8);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            width: 36px;
            height: 36px;
            display: none;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: #888;
            font-size: 18px;
        }
        .controls.hidden ~ .toggle-panel { display: flex; }

        /* Julia preview */
        .julia-preview {
            position: fixed;
            bottom: 16px;
            right: 16px;
            width: 200px;
            height: 200px;
            border: 1px solid rgba(255,255,255,0.08);
            border-radius: 8px;
            overflow: hidden;
            z-index: 10;
            cursor: pointer;
            transition: opacity 0.3s;
        }
        .julia-preview canvas {
            width: 100%;
            height: 100%;
        }
        .julia-label {
            position: absolute;
            top: 6px;
            left: 8px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            color: rgba(255,255,255,0.5);
        }

        /* Presets */
        .presets {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            margin-top: 8px;
        }
        .preset-btn {
            font-size: 10px !important;
            padding: 5px 6px !important;
            text-align: center;
        }
    </style>
</head>
<body>
    <a href="../index.html#lab" class="back">‚Üê Back to Lab</a>

    <canvas id="main"></canvas>

    <div class="controls" id="controls">
        <h3>üî¨ Fractal Explorer</h3>

        <div class="control-group">
            <label>Mode</label>
            <select id="mode">
                <option value="mandelbrot">Mandelbrot Set</option>
                <option value="julia">Julia Set</option>
                <option value="burning-ship">Burning Ship</option>
                <option value="tricorn">Tricorn</option>
            </select>
        </div>

        <div class="control-group">
            <label>Iterations <span id="iter-val">256</span></label>
            <input type="range" id="iterations" min="32" max="2048" value="256" step="32">
        </div>

        <div class="control-group">
            <label>Color Scheme</label>
            <select id="colorScheme">
                <option value="0">Ultra Fractal</option>
                <option value="1">Electric</option>
                <option value="2">Fire</option>
                <option value="3">Ocean</option>
                <option value="4">Monochrome</option>
                <option value="5">Psychedelic</option>
                <option value="6">Sunset</option>
                <option value="7">Ice</option>
            </select>
        </div>

        <div class="control-group">
            <label>Color Speed <span id="speed-val">1.0</span></label>
            <input type="range" id="colorSpeed" min="0.1" max="5.0" value="1.0" step="0.1">
        </div>

        <div class="control-group">
            <label>Smooth Coloring</label>
            <select id="smooth">
                <option value="1">On</option>
                <option value="0">Off (banded)</option>
            </select>
        </div>

        <div class="presets">
            <button class="preset-btn" data-preset="seahorse">Seahorse Valley</button>
            <button class="preset-btn" data-preset="spiral">Spiral</button>
            <button class="preset-btn" data-preset="mini">Mini-brot</button>
            <button class="preset-btn" data-preset="elephant">Elephant Valley</button>
            <button class="preset-btn" data-preset="dendrite">Dendrite</button>
            <button class="preset-btn" data-preset="reset">Reset View</button>
        </div>

        <div class="btn-row" style="margin-top: 12px;">
            <button id="saveBtn">üì∑ Save PNG</button>
            <button id="hideBtn">Hide Panel</button>
        </div>
    </div>

    <button class="toggle-panel" id="showBtn">‚öô</button>

    <div class="julia-preview" id="juliaPreview">
        <div class="julia-label">Julia c = <span id="julia-c">0.00, 0.00</span></div>
        <canvas id="julia" width="400" height="400"></canvas>
    </div>

    <div class="info" id="info">
        <div>center: <span id="info-center">0.0, 0.0</span></div>
        <div>zoom: <span id="info-zoom">1.0√ó</span></div>
        <div>scroll to zoom ¬∑ drag to pan ¬∑ hover for julia preview</div>
    </div>

    <script>
    const mainCanvas = document.getElementById('main');
    const juliaCanvas = document.getElementById('julia');

    // WebGL setup
    function initGL(canvas) {
        const gl = canvas.getContext('webgl', { preserveDrawingBuffer: true });
        if (!gl) { alert('WebGL not supported'); return null; }
        return gl;
    }

    const gl = initGL(mainCanvas);
    const glJ = initGL(juliaCanvas);

    // Shader source
    const vertSrc = `
        attribute vec2 a_pos;
        void main() { gl_Position = vec4(a_pos, 0.0, 1.0); }
    `;

    const fragSrc = `
        precision highp float;
        uniform vec2 u_resolution;
        uniform vec2 u_center;
        uniform float u_zoom;
        uniform int u_maxIter;
        uniform int u_colorScheme;
        uniform float u_colorSpeed;
        uniform int u_smooth;
        uniform int u_mode; // 0=mandelbrot, 1=julia, 2=burning-ship, 3=tricorn
        uniform vec2 u_juliaC;

        vec3 palette(float t, int scheme) {
            if (scheme == 0) { // Ultra Fractal
                return 0.5 + 0.5 * cos(6.28318 * (t * vec3(1.0, 1.0, 1.0) + vec3(0.0, 0.1, 0.2)));
            } else if (scheme == 1) { // Electric
                return 0.5 + 0.5 * cos(6.28318 * (t * vec3(1.0, 1.0, 1.0) + vec3(0.0, 0.33, 0.67)));
            } else if (scheme == 2) { // Fire
                return vec3(t, t*t*0.7, t*t*t*0.4);
            } else if (scheme == 3) { // Ocean
                return 0.5 + 0.5 * cos(6.28318 * (t * vec3(0.8, 1.0, 1.2) + vec3(0.5, 0.6, 0.7)));
            } else if (scheme == 4) { // Mono
                float v = 0.5 + 0.5 * cos(6.28318 * t);
                return vec3(v);
            } else if (scheme == 5) { // Psychedelic
                return 0.5 + 0.5 * cos(6.28318 * (t * vec3(3.0, 3.0, 3.0) + vec3(0.0, 0.25, 0.5)));
            } else if (scheme == 6) { // Sunset
                return 0.5 + 0.5 * cos(6.28318 * (t * vec3(1.0, 0.8, 0.6) + vec3(0.0, 0.15, 0.4)));
            } else { // Ice
                return 0.5 + 0.5 * cos(6.28318 * (t * vec3(0.6, 0.8, 1.0) + vec3(0.6, 0.7, 0.8)));
            }
        }

        void main() {
            vec2 uv = (gl_FragCoord.xy - u_resolution * 0.5) / min(u_resolution.x, u_resolution.y);
            vec2 c, z;

            if (u_mode == 1) { // Julia
                z = uv * 2.0 / u_zoom + u_center;
                c = u_juliaC;
            } else {
                c = uv * 2.0 / u_zoom + u_center;
                z = vec2(0.0);
            }

            float iter = 0.0;
            float maxI = float(u_maxIter);

            for (int i = 0; i < 2048; i++) {
                if (i >= u_maxIter) break;

                float x2 = z.x * z.x;
                float y2 = z.y * z.y;
                if (x2 + y2 > 256.0) break;

                if (u_mode == 2) { // Burning Ship
                    z = vec2(x2 - y2, 2.0 * abs(z.x * z.y)) + c;
                } else if (u_mode == 3) { // Tricorn
                    z = vec2(x2 - y2, -2.0 * z.x * z.y) + c;
                } else {
                    z = vec2(x2 - y2, 2.0 * z.x * z.y) + c;
                }

                iter += 1.0;
            }

            if (iter >= maxI) {
                gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
            } else {
                float t;
                if (u_smooth == 1) {
                    float sl = iter - log2(log2(dot(z, z))) + 4.0;
                    t = sl / maxI * u_colorSpeed * 10.0;
                } else {
                    t = iter / maxI * u_colorSpeed * 10.0;
                }
                vec3 col = palette(t, u_colorScheme);
                gl_FragColor = vec4(col, 1.0);
            }
        }
    `;

    function createProgram(ctx) {
        const vs = ctx.createShader(ctx.VERTEX_SHADER);
        ctx.shaderSource(vs, vertSrc);
        ctx.compileShader(vs);
        const fs = ctx.createShader(ctx.FRAGMENT_SHADER);
        ctx.shaderSource(fs, fragSrc);
        ctx.compileShader(fs);
        if (!ctx.getShaderParameter(fs, ctx.COMPILE_STATUS)) {
            console.error(ctx.getShaderInfoLog(fs));
        }
        const prog = ctx.createProgram();
        ctx.attachShader(prog, vs);
        ctx.attachShader(prog, fs);
        ctx.linkProgram(prog);
        ctx.useProgram(prog);

        const buf = ctx.createBuffer();
        ctx.bindBuffer(ctx.ARRAY_BUFFER, buf);
        ctx.bufferData(ctx.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), ctx.STATIC_DRAW);
        const loc = ctx.getAttribLocation(prog, 'a_pos');
        ctx.enableVertexAttribArray(loc);
        ctx.vertexAttribPointer(loc, 2, ctx.FLOAT, false, 0, 0);

        return prog;
    }

    const mainProg = createProgram(gl);
    const juliaProg = createProgram(glJ);

    // State
    let state = {
        cx: -0.5, cy: 0.0,
        zoom: 1.0,
        maxIter: 256,
        colorScheme: 0,
        colorSpeed: 1.0,
        smooth: 1,
        mode: 0,
        juliaX: -0.7, juliaY: 0.27015,
        mouseX: 0, mouseY: 0
    };

    function render(ctx, prog, canvas, overrides = {}) {
        const s = { ...state, ...overrides };
        ctx.viewport(0, 0, canvas.width, canvas.height);
        ctx.uniform2f(ctx.getUniformLocation(prog, 'u_resolution'), canvas.width, canvas.height);
        ctx.uniform2f(ctx.getUniformLocation(prog, 'u_center'), s.cx, s.cy);
        ctx.uniform1f(ctx.getUniformLocation(prog, 'u_zoom'), s.zoom);
        ctx.uniform1i(ctx.getUniformLocation(prog, 'u_maxIter'), s.maxIter);
        ctx.uniform1i(ctx.getUniformLocation(prog, 'u_colorScheme'), s.colorScheme);
        ctx.uniform1f(ctx.getUniformLocation(prog, 'u_colorSpeed'), s.colorSpeed);
        ctx.uniform1i(ctx.getUniformLocation(prog, 'u_smooth'), s.smooth);
        ctx.uniform1i(ctx.getUniformLocation(prog, 'u_mode'), s.mode);
        ctx.uniform2f(ctx.getUniformLocation(prog, 'u_juliaC'), s.juliaX, s.juliaY);
        ctx.drawArrays(ctx.TRIANGLE_STRIP, 0, 4);
    }

    function resize() {
        const dpr = window.devicePixelRatio || 1;
        mainCanvas.width = window.innerWidth * dpr;
        mainCanvas.height = window.innerHeight * dpr;
        renderAll();
    }

    function renderAll() {
        render(gl, mainProg, mainCanvas);
        // Julia preview shows the Julia set for wherever the mouse is on the Mandelbrot
        if (state.mode === 0) {
            render(glJ, juliaProg, juliaCanvas, {
                mode: 1, cx: 0, cy: 0, zoom: 0.8,
                juliaX: state.mouseX, juliaY: state.mouseY
            });
            document.getElementById('julia-c').textContent =
                `${state.mouseX.toFixed(4)}, ${state.mouseY.toFixed(4)}`;
        }
        updateInfo();
    }

    function updateInfo() {
        document.getElementById('info-center').textContent =
            `${state.cx.toFixed(8)}, ${state.cy.toFixed(8)}`;
        document.getElementById('info-zoom').textContent =
            state.zoom >= 1e6 ? (state.zoom).toExponential(2) + '√ó' : state.zoom.toFixed(1) + '√ó';
    }

    // Interaction
    let dragging = false, lastX, lastY;

    mainCanvas.addEventListener('mousedown', e => {
        dragging = true;
        lastX = e.clientX;
        lastY = e.clientY;
    });
    window.addEventListener('mouseup', () => dragging = false);
    window.addEventListener('mousemove', e => {
        if (dragging) {
            const scale = 2.0 / (state.zoom * Math.min(mainCanvas.width, mainCanvas.height) / (window.devicePixelRatio || 1));
            state.cx -= (e.clientX - lastX) * scale;
            state.cy += (e.clientY - lastY) * scale;
            lastX = e.clientX;
            lastY = e.clientY;
            renderAll();
        } else if (state.mode === 0) {
            // Update julia preview based on mouse position on Mandelbrot
            const rect = mainCanvas.getBoundingClientRect();
            const w = rect.width, h = rect.height;
            const minDim = Math.min(w, h);
            state.mouseX = ((e.clientX - rect.left) - w/2) / minDim * 2.0 / state.zoom + state.cx;
            state.mouseY = -( ((e.clientY - rect.top) - h/2) / minDim * 2.0 / state.zoom + state.cy);
            // Fix: Y is flipped in screen coords
            state.mouseY = ((e.clientY - rect.top) - h/2) / minDim * 2.0 / state.zoom;
            state.mouseY = -(((e.clientY - rect.top) - h/2) / minDim * 2.0 / state.zoom - state.cy);
            // Simpler:
            const ux = ((e.clientX - rect.left) - w*0.5) / minDim * 2.0 / state.zoom + state.cx;
            const uy = -(((e.clientY - rect.top) - h*0.5) / minDim * 2.0 / state.zoom) + state.cy;
            state.mouseX = ux;
            state.mouseY = uy;
            renderAll();
        }
    });

    mainCanvas.addEventListener('wheel', e => {
        e.preventDefault();
        const factor = e.deltaY < 0 ? 1.3 : 1/1.3;

        // Zoom towards mouse position
        const rect = mainCanvas.getBoundingClientRect();
        const w = rect.width, h = rect.height;
        const minDim = Math.min(w, h);
        const mx = ((e.clientX - rect.left) - w*0.5) / minDim * 2.0 / state.zoom + state.cx;
        const my = -(((e.clientY - rect.top) - h*0.5) / minDim * 2.0 / state.zoom) + state.cy;

        state.cx = mx + (state.cx - mx) / factor;
        state.cy = my + (state.cy - my) / factor;
        state.zoom *= factor;

        // Auto-increase iterations at deep zoom
        if (state.zoom > 1000 && state.maxIter < 512) {
            state.maxIter = 512;
            document.getElementById('iterations').value = 512;
            document.getElementById('iter-val').textContent = 512;
        }
        if (state.zoom > 100000 && state.maxIter < 1024) {
            state.maxIter = 1024;
            document.getElementById('iterations').value = 1024;
            document.getElementById('iter-val').textContent = 1024;
        }

        renderAll();
    }, { passive: false });

    // Touch support
    let lastTouchDist = 0, lastTouchX = 0, lastTouchY = 0;
    mainCanvas.addEventListener('touchstart', e => {
        if (e.touches.length === 1) {
            dragging = true;
            lastX = e.touches[0].clientX;
            lastY = e.touches[0].clientY;
        } else if (e.touches.length === 2) {
            dragging = false;
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            lastTouchDist = Math.sqrt(dx*dx + dy*dy);
        }
        e.preventDefault();
    }, { passive: false });
    mainCanvas.addEventListener('touchmove', e => {
        if (e.touches.length === 1 && dragging) {
            const scale = 2.0 / (state.zoom * Math.min(mainCanvas.width, mainCanvas.height) / (window.devicePixelRatio || 1));
            state.cx -= (e.touches[0].clientX - lastX) * scale;
            state.cy += (e.touches[0].clientY - lastY) * scale;
            lastX = e.touches[0].clientX;
            lastY = e.touches[0].clientY;
            renderAll();
        } else if (e.touches.length === 2) {
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (lastTouchDist > 0) {
                state.zoom *= dist / lastTouchDist;
                renderAll();
            }
            lastTouchDist = dist;
        }
        e.preventDefault();
    }, { passive: false });
    mainCanvas.addEventListener('touchend', () => { dragging = false; lastTouchDist = 0; });

    // Click Julia preview to switch to Julia mode with that c value
    document.getElementById('juliaPreview').addEventListener('click', () => {
        state.juliaX = state.mouseX;
        state.juliaY = state.mouseY;
        state.mode = 1;
        state.cx = 0; state.cy = 0; state.zoom = 0.8;
        document.getElementById('mode').value = 'julia';
        renderAll();
    });

    // Controls
    document.getElementById('iterations').addEventListener('input', e => {
        state.maxIter = parseInt(e.target.value);
        document.getElementById('iter-val').textContent = state.maxIter;
        renderAll();
    });
    document.getElementById('colorScheme').addEventListener('change', e => {
        state.colorScheme = parseInt(e.target.value);
        renderAll();
    });
    document.getElementById('colorSpeed').addEventListener('input', e => {
        state.colorSpeed = parseFloat(e.target.value);
        document.getElementById('speed-val').textContent = state.colorSpeed.toFixed(1);
        renderAll();
    });
    document.getElementById('smooth').addEventListener('change', e => {
        state.smooth = parseInt(e.target.value);
        renderAll();
    });
    document.getElementById('mode').addEventListener('change', e => {
        const modes = { 'mandelbrot': 0, 'julia': 1, 'burning-ship': 2, 'tricorn': 3 };
        state.mode = modes[e.target.value];
        if (state.mode === 0) { state.cx = -0.5; state.cy = 0; state.zoom = 1; }
        else if (state.mode === 1) { state.cx = 0; state.cy = 0; state.zoom = 0.8; }
        else if (state.mode === 2) { state.cx = -0.4; state.cy = -0.5; state.zoom = 0.8; }
        else if (state.mode === 3) { state.cx = -0.3; state.cy = 0; state.zoom = 0.8; }
        document.getElementById('juliaPreview').style.opacity = state.mode === 0 ? '1' : '0.3';
        renderAll();
    });

    // Presets
    const presets = {
        'seahorse': { cx: -0.7463, cy: 0.1102, zoom: 200, maxIter: 512 },
        'spiral': { cx: -0.7435669, cy: 0.1314023, zoom: 20000, maxIter: 1024 },
        'mini': { cx: -1.7490863, cy: 0.0, zoom: 2000, maxIter: 1024 },
        'elephant': { cx: 0.2821, cy: 0.0100, zoom: 150, maxIter: 512 },
        'dendrite': { cx: -0.1011, cy: 0.9563, zoom: 80, maxIter: 512 },
        'reset': { cx: -0.5, cy: 0.0, zoom: 1, maxIter: 256 }
    };

    document.querySelectorAll('.preset-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            const p = presets[btn.dataset.preset];
            if (p) {
                state.cx = p.cx; state.cy = p.cy; state.zoom = p.zoom;
                state.maxIter = p.maxIter; state.mode = 0;
                document.getElementById('iterations').value = p.maxIter;
                document.getElementById('iter-val').textContent = p.maxIter;
                document.getElementById('mode').value = 'mandelbrot';
                renderAll();
            }
        });
    });

    // Save
    document.getElementById('saveBtn').addEventListener('click', () => {
        const link = document.createElement('a');
        link.download = `fractal-${Date.now()}.png`;
        link.href = mainCanvas.toDataURL('image/png');
        link.click();
    });

    // Panel toggle
    document.getElementById('hideBtn').addEventListener('click', () => {
        document.getElementById('controls').classList.add('hidden');
    });
    document.getElementById('showBtn').addEventListener('click', () => {
        document.getElementById('controls').classList.remove('hidden');
    });

    // Init
    window.addEventListener('resize', resize);
    resize();
    </script>
    <script src="../command-palette.js"></script>
</body>
</html>
