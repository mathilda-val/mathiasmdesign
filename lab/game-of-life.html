<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game of Life — M×M Lab</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0a0f;
            color: #e0e0e0;
            font-family: 'Space Grotesk', sans-serif;
            overflow: hidden;
            height: 100vh;
            touch-action: none;
        }
        canvas#grid {
            display: block;
            width: 100vw;
            height: 100vh;
            cursor: crosshair;
        }

        /* ── Controls Panel ── */
        .controls {
            position: fixed;
            top: 16px;
            right: 16px;
            background: rgba(10, 10, 15, 0.92);
            border: 1px solid rgba(255,255,255,0.08);
            border-radius: 12px;
            padding: 20px;
            width: 300px;
            backdrop-filter: blur(20px);
            z-index: 10;
            font-size: 13px;
            transition: transform 0.3s ease;
            max-height: calc(100vh - 32px);
            overflow-y: auto;
        }
        .controls.hidden { transform: translateX(340px); }
        .controls h3 {
            font-size: 15px;
            margin-bottom: 12px;
            color: #fff;
            font-weight: 600;
            cursor: pointer;
            user-select: none;
        }
        .control-group {
            margin-bottom: 14px;
        }
        .control-group label {
            display: block;
            margin-bottom: 4px;
            color: #888;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .control-group select,
        .control-group input[type="number"] {
            width: 100%;
            background: rgba(255,255,255,0.06);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 6px;
            color: #fff;
            padding: 6px 8px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
        }
        .control-group input[type="range"] {
            width: 100%;
            -webkit-appearance: none;
            height: 4px;
            border: none;
            border-radius: 2px;
            background: rgba(255,255,255,0.15);
            padding: 0;
        }
        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px; height: 14px;
            border-radius: 50%;
            background: #fff;
            cursor: pointer;
        }
        .val {
            float: right;
            font-family: 'JetBrains Mono', monospace;
            color: #aaa;
        }

        .btn-row {
            display: flex;
            gap: 6px;
            margin-bottom: 12px;
            flex-wrap: wrap;
        }
        .btn {
            flex: 1;
            min-width: 0;
            padding: 8px 4px;
            border: 1px solid rgba(255,255,255,0.12);
            border-radius: 6px;
            background: rgba(255,255,255,0.06);
            color: #fff;
            font-family: 'Space Grotesk', sans-serif;
            font-size: 12px;
            cursor: pointer;
            text-align: center;
            transition: background 0.15s;
            white-space: nowrap;
        }
        .btn:hover { background: rgba(255,255,255,0.12); }
        .btn.active { background: rgba(255,255,255,0.18); border-color: rgba(255,255,255,0.25); }

        .stats {
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            color: #888;
            margin-bottom: 12px;
            line-height: 1.6;
        }
        .stats span { color: #ccc; }

        /* ── Pattern Library ── */
        .patterns {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }
        .pattern-btn {
            padding: 4px 8px;
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 4px;
            background: rgba(255,255,255,0.04);
            color: #aaa;
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.15s;
        }
        .pattern-btn:hover { background: rgba(255,255,255,0.1); color: #fff; }
        .pattern-btn.active { background: rgba(100,200,255,0.15); color: #fff; border-color: rgba(100,200,255,0.4); }

        .color-swatches {
            display: flex;
            gap: 4px;
        }
        .swatch {
            width: 24px; height: 24px;
            border-radius: 4px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: border-color 0.15s;
        }
        .swatch.active { border-color: #fff; }

        .toggle-btn {
            position: fixed;
            top: 16px;
            right: 16px;
            width: 36px; height: 36px;
            border-radius: 8px;
            background: rgba(10,10,15,0.8);
            border: 1px solid rgba(255,255,255,0.1);
            color: #fff;
            font-size: 16px;
            cursor: pointer;
            z-index: 11;
            display: none;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(10px);
        }
        .controls.hidden ~ .toggle-btn { display: flex; }

        .info-line {
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            color: #555;
            margin-top: 10px;
            line-height: 1.5;
        }
        .info-line a { color: #888; }

        .placement-hint {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(10,10,15,0.9);
            border: 1px solid rgba(100,200,255,0.3);
            border-radius: 8px;
            padding: 8px 16px;
            color: #7cc;
            font-size: 12px;
            z-index: 20;
            display: none;
            backdrop-filter: blur(10px);
        }

        @media (max-width: 640px) {
            .controls { width: calc(100vw - 32px); right: 16px; top: auto; bottom: 16px; max-height: 50vh; }
            .controls.hidden { transform: translateY(calc(100% + 32px)); }
            .toggle-btn { top: auto; bottom: 16px; }
        }
    </style>
</head>
<body>
    <canvas id="grid"></canvas>

    <div class="controls" id="controls">
        <h3>Conway's Game of Life</h3>

        <div class="stats" id="stats">
            Gen: <span id="genCount">0</span> &nbsp;|&nbsp; Pop: <span id="popCount">0</span>
        </div>

        <div class="btn-row">
            <button class="btn" id="btnPlay">▶ Play</button>
            <button class="btn" id="btnStep">⏭ Step</button>
        </div>
        <div class="btn-row">
            <button class="btn" id="btnClear">Clear</button>
            <button class="btn" id="btnRandom">Random</button>
        </div>

        <div class="control-group">
            <label>Speed <span class="val" id="speedVal">10</span> gen/s</label>
            <input type="range" id="speed" min="1" max="60" value="10">
        </div>

        <div class="control-group">
            <label>Grid Size <span class="val" id="gridVal">100</span></label>
            <input type="range" id="gridSize" min="20" max="500" value="100" step="10">
        </div>

        <div class="control-group">
            <label>Theme</label>
            <div class="color-swatches" id="themes"></div>
        </div>

        <div class="control-group">
            <label>Patterns <span style="font-size:9px;color:#666">(click to select, click grid to place)</span></label>
            <div class="patterns" id="patterns"></div>
        </div>

        <div class="info-line">
            Scroll to zoom · Drag to draw · Double-click title to hide<br>
            <a href="../index.html#lab">← Back to Lab</a>
        </div>
    </div>

    <button class="toggle-btn" id="toggleBtn">⚙</button>
    <div class="placement-hint" id="placementHint">Click on grid to place pattern · Right-click or Esc to cancel</div>

    <script>
    const canvas = document.getElementById('grid');
    const ctx = canvas.getContext('2d');

    // ── State ──
    let cols = 100, rows = 100;
    let cellSize = 6;
    let grid, nextGrid;
    let running = false;
    let generation = 0;
    let population = 0;
    let speed = 10;
    let lastFrame = 0;
    let offsetX = 0, offsetY = 0;
    let zoom = 1;
    let drawing = false;
    let drawVal = 1;
    let selectedPattern = null;

    // ── Themes ──
    const themes = {
        'Classic':  { bg: '#0a0a0f', dead: '#151520', alive: '#ffffff', grid: 'rgba(255,255,255,0.04)' },
        'Matrix':   { bg: '#000a00', dead: '#001a00', alive: '#00ff41', grid: 'rgba(0,255,65,0.06)' },
        'Ocean':    { bg: '#040810', dead: '#0a1525', alive: '#00bfff', grid: 'rgba(0,191,255,0.06)' },
        'Ember':    { bg: '#100804', dead: '#1a0e08', alive: '#ff6622', grid: 'rgba(255,102,34,0.05)' },
        'Violet':   { bg: '#0a0410', dead: '#150a20', alive: '#bf5fff', grid: 'rgba(191,95,255,0.06)' },
    };
    let theme = themes['Classic'];

    // ── Patterns ──
    const PATTERNS = {
        'Glider': [[0,1],[1,2],[2,0],[2,1],[2,2]],
        'LWSS': [[0,1],[0,4],[1,0],[2,0],[2,4],[3,0],[3,1],[3,2],[3,3]],
        'R-pentomino': [[0,1],[0,2],[1,0],[1,1],[2,1]],
        'Acorn': [[0,1],[1,3],[2,0],[2,1],[2,4],[2,5],[2,6]],
        'Pulsar': (()=>{
            const pts = [];
            const c = [[2,1],[3,1],[4,1],[1,2],[1,3],[1,4],[6,2],[6,3],[6,4],[2,6],[3,6],[4,6]];
            for(const [r,cl] of c) { pts.push([r,cl],[r,cl+7],[r+7,cl],[r+7,cl+7]); }
            return pts;
        })(),
        'Pentadecathlon': (()=>{
            const pts = [];
            const rows = [0,1,2,3,4,5,6,7,8,9];
            for(const r of rows) {
                if(r===1||r===8) { pts.push([r,0],[r,2]); }
                else { pts.push([r,1]); }
            }
            return pts;
        })(),
        'Gosper Gun': [
            [0,24],[1,22],[1,24],[2,12],[2,13],[2,20],[2,21],[2,34],[2,35],
            [3,11],[3,15],[3,20],[3,21],[3,34],[3,35],
            [4,0],[4,1],[4,10],[4,16],[4,20],[4,21],
            [5,0],[5,1],[5,10],[5,14],[5,16],[5,17],[5,22],[5,24],
            [6,10],[6,16],[6,24],
            [7,11],[7,15],
            [8,12],[8,13]
        ],
    };

    // ── Init ──
    function makeGrid(c, r) {
        return new Uint8Array(c * r);
    }

    function init() {
        grid = makeGrid(cols, rows);
        nextGrid = makeGrid(cols, rows);
        generation = 0;
        centerView();
    }

    function centerView() {
        const dpr = window.devicePixelRatio || 1;
        canvas.width = window.innerWidth * dpr;
        canvas.height = window.innerHeight * dpr;
        canvas.style.width = window.innerWidth + 'px';
        canvas.style.height = window.innerHeight + 'px';
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

        cellSize = Math.max(2, Math.min(
            window.innerWidth / cols,
            window.innerHeight / rows
        ) * 0.85);
        zoom = 1;
        offsetX = (window.innerWidth - cols * cellSize) / 2;
        offsetY = (window.innerHeight - rows * cellSize) / 2;
    }

    // ── Simulation ──
    function step() {
        population = 0;
        for (let y = 0; y < rows; y++) {
            for (let x = 0; x < cols; x++) {
                let neighbors = 0;
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        if (dx === 0 && dy === 0) continue;
                        const nx = (x + dx + cols) % cols;
                        const ny = (y + dy + rows) % rows;
                        neighbors += grid[ny * cols + nx];
                    }
                }
                const idx = y * cols + x;
                const alive = grid[idx];
                if (alive) {
                    nextGrid[idx] = (neighbors === 2 || neighbors === 3) ? 1 : 0;
                } else {
                    nextGrid[idx] = (neighbors === 3) ? 1 : 0;
                }
                population += nextGrid[idx];
            }
        }
        [grid, nextGrid] = [nextGrid, grid];
        generation++;
        document.getElementById('genCount').textContent = generation;
        document.getElementById('popCount').textContent = population;
    }

    // ── Render ──
    function render() {
        const w = window.innerWidth, h = window.innerHeight;
        ctx.fillStyle = theme.bg;
        ctx.fillRect(0, 0, w, h);

        const cs = cellSize * zoom;
        const startCol = Math.max(0, Math.floor(-offsetX / cs));
        const endCol = Math.min(cols, Math.ceil((w - offsetX) / cs));
        const startRow = Math.max(0, Math.floor(-offsetY / cs));
        const endRow = Math.min(rows, Math.ceil((h - offsetY) / cs));

        // Dead cells bg
        ctx.fillStyle = theme.dead;
        for (let y = startRow; y < endRow; y++) {
            for (let x = startCol; x < endCol; x++) {
                ctx.fillRect(
                    offsetX + x * cs + 0.5,
                    offsetY + y * cs + 0.5,
                    cs - 1,
                    cs - 1
                );
            }
        }

        // Alive cells
        ctx.fillStyle = theme.alive;
        for (let y = startRow; y < endRow; y++) {
            for (let x = startCol; x < endCol; x++) {
                if (grid[y * cols + x]) {
                    ctx.fillRect(
                        offsetX + x * cs + 0.5,
                        offsetY + y * cs + 0.5,
                        cs - 1,
                        cs - 1
                    );
                }
            }
        }

        // Pattern preview
        if (selectedPattern) {
            ctx.fillStyle = theme.alive;
            ctx.globalAlpha = 0.3;
            const pat = PATTERNS[selectedPattern];
            if (pat && hoverCell) {
                for (const [r, c] of pat) {
                    const gx = (hoverCell.x + c) % cols;
                    const gy = (hoverCell.y + r) % rows;
                    ctx.fillRect(
                        offsetX + gx * cs + 0.5,
                        offsetY + gy * cs + 0.5,
                        cs - 1,
                        cs - 1
                    );
                }
            }
            ctx.globalAlpha = 1;
        }
    }

    let hoverCell = null;

    function gameLoop(ts) {
        if (running && ts - lastFrame >= 1000 / speed) {
            step();
            lastFrame = ts;
        }
        render();
        requestAnimationFrame(gameLoop);
    }

    // ── Mouse / Touch ──
    function screenToCell(sx, sy) {
        const cs = cellSize * zoom;
        const x = Math.floor((sx - offsetX) / cs);
        const y = Math.floor((sy - offsetY) / cs);
        if (x >= 0 && x < cols && y >= 0 && y < rows) return { x, y };
        return null;
    }

    let panning = false;
    let panStart = { x: 0, y: 0 };
    let panOffset = { x: 0, y: 0 };

    canvas.addEventListener('mousedown', (e) => {
        if (e.button === 1 || (e.button === 0 && e.shiftKey)) {
            panning = true;
            panStart = { x: e.clientX, y: e.clientY };
            panOffset = { x: offsetX, y: offsetY };
            canvas.style.cursor = 'grabbing';
            return;
        }
        if (e.button === 2 && selectedPattern) {
            selectedPattern = null;
            updatePatternUI();
            document.getElementById('placementHint').style.display = 'none';
            return;
        }
        const cell = screenToCell(e.clientX, e.clientY);
        if (!cell) return;

        if (selectedPattern) {
            placePattern(cell.x, cell.y, selectedPattern);
            selectedPattern = null;
            updatePatternUI();
            document.getElementById('placementHint').style.display = 'none';
            return;
        }

        drawing = true;
        const idx = cell.y * cols + cell.x;
        drawVal = grid[idx] ? 0 : 1;
        grid[idx] = drawVal;
        updatePop();
    });

    canvas.addEventListener('mousemove', (e) => {
        if (panning) {
            offsetX = panOffset.x + (e.clientX - panStart.x);
            offsetY = panOffset.y + (e.clientY - panStart.y);
            return;
        }
        hoverCell = screenToCell(e.clientX, e.clientY);
        if (drawing && hoverCell) {
            grid[hoverCell.y * cols + hoverCell.x] = drawVal;
        }
    });

    canvas.addEventListener('mouseup', () => { drawing = false; panning = false; canvas.style.cursor = 'crosshair'; });
    canvas.addEventListener('mouseleave', () => { drawing = false; hoverCell = null; });
    canvas.addEventListener('contextmenu', (e) => e.preventDefault());

    // Touch
    let lastTouchDist = 0;
    canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        if (e.touches.length === 2) {
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            lastTouchDist = Math.hypot(dx, dy);
            panning = true;
            panStart = {
                x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
                y: (e.touches[0].clientY + e.touches[1].clientY) / 2,
            };
            panOffset = { x: offsetX, y: offsetY };
            return;
        }
        const t = e.touches[0];
        const cell = screenToCell(t.clientX, t.clientY);
        if (!cell) return;
        if (selectedPattern) {
            placePattern(cell.x, cell.y, selectedPattern);
            selectedPattern = null;
            updatePatternUI();
            document.getElementById('placementHint').style.display = 'none';
            return;
        }
        drawing = true;
        const idx = cell.y * cols + cell.x;
        drawVal = grid[idx] ? 0 : 1;
        grid[idx] = drawVal;
    }, { passive: false });

    canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        if (e.touches.length === 2) {
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            const dist = Math.hypot(dx, dy);
            const mid = {
                x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
                y: (e.touches[0].clientY + e.touches[1].clientY) / 2,
            };
            if (panning) {
                const scale = dist / lastTouchDist;
                const newZoom = Math.max(0.2, Math.min(10, zoom * scale));
                const zf = newZoom / zoom;
                offsetX = mid.x - (mid.x - offsetX) * zf;
                offsetY = mid.y - (mid.y - offsetY) * zf;
                zoom = newZoom;
                offsetX = panOffset.x + (mid.x - panStart.x);
                offsetY = panOffset.y + (mid.y - panStart.y);
            }
            lastTouchDist = dist;
            panStart = mid;
            panOffset = { x: offsetX, y: offsetY };
            return;
        }
        const t = e.touches[0];
        hoverCell = screenToCell(t.clientX, t.clientY);
        if (drawing && hoverCell) {
            grid[hoverCell.y * cols + hoverCell.x] = drawVal;
        }
    }, { passive: false });

    canvas.addEventListener('touchend', () => { drawing = false; panning = false; });

    // Scroll zoom
    canvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        const factor = e.deltaY < 0 ? 1.1 : 0.9;
        const newZoom = Math.max(0.2, Math.min(10, zoom * factor));
        const zf = newZoom / zoom;
        offsetX = e.clientX - (e.clientX - offsetX) * zf;
        offsetY = e.clientY - (e.clientY - offsetY) * zf;
        zoom = newZoom;
    }, { passive: false });

    // Esc to cancel pattern
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && selectedPattern) {
            selectedPattern = null;
            updatePatternUI();
            document.getElementById('placementHint').style.display = 'none';
        }
        if (e.key === ' ') { e.preventDefault(); togglePlay(); }
    });

    // ── Helpers ──
    function placePattern(cx, cy, name) {
        const pat = PATTERNS[name];
        if (!pat) return;
        for (const [r, c] of pat) {
            const gx = (cx + c) % cols;
            const gy = (cy + r) % rows;
            grid[gy * cols + gx] = 1;
        }
        updatePop();
    }

    function updatePop() {
        population = 0;
        for (let i = 0; i < grid.length; i++) population += grid[i];
        document.getElementById('popCount').textContent = population;
    }

    function togglePlay() {
        running = !running;
        document.getElementById('btnPlay').textContent = running ? '⏸ Pause' : '▶ Play';
        document.getElementById('btnPlay').classList.toggle('active', running);
    }

    function randomize() {
        for (let i = 0; i < grid.length; i++) {
            grid[i] = Math.random() < 0.25 ? 1 : 0;
        }
        generation = 0;
        document.getElementById('genCount').textContent = 0;
        updatePop();
    }

    function resizeGrid(newSize) {
        const oldGrid = grid;
        const oldCols = cols, oldRows = rows;
        cols = newSize;
        rows = newSize;
        grid = makeGrid(cols, rows);
        nextGrid = makeGrid(cols, rows);
        // Copy old data centered
        const dx = Math.floor((cols - oldCols) / 2);
        const dy = Math.floor((rows - oldRows) / 2);
        for (let y = 0; y < oldRows; y++) {
            for (let x = 0; x < oldCols; x++) {
                const nx = x + dx, ny = y + dy;
                if (nx >= 0 && nx < cols && ny >= 0 && ny < rows) {
                    grid[ny * cols + nx] = oldGrid[y * oldCols + x];
                }
            }
        }
        centerView();
        updatePop();
    }

    // ── UI Setup ──
    // Themes
    const themesEl = document.getElementById('themes');
    Object.entries(themes).forEach(([name, t], i) => {
        const s = document.createElement('div');
        s.className = 'swatch' + (i === 0 ? ' active' : '');
        s.style.background = t.alive;
        s.title = name;
        s.addEventListener('click', () => {
            theme = t;
            document.body.style.background = t.bg;
            themesEl.querySelectorAll('.swatch').forEach(el => el.classList.remove('active'));
            s.classList.add('active');
        });
        themesEl.appendChild(s);
    });

    // Patterns
    function updatePatternUI() {
        document.querySelectorAll('.pattern-btn').forEach(b => {
            b.classList.toggle('active', b.dataset.name === selectedPattern);
        });
    }

    const patternsEl = document.getElementById('patterns');
    Object.keys(PATTERNS).forEach(name => {
        const b = document.createElement('button');
        b.className = 'pattern-btn';
        b.textContent = name;
        b.dataset.name = name;
        b.addEventListener('click', () => {
            if (selectedPattern === name) {
                selectedPattern = null;
                document.getElementById('placementHint').style.display = 'none';
            } else {
                selectedPattern = name;
                document.getElementById('placementHint').style.display = 'block';
            }
            updatePatternUI();
        });
        patternsEl.appendChild(b);
    });

    // Controls
    document.getElementById('btnPlay').addEventListener('click', togglePlay);
    document.getElementById('btnStep').addEventListener('click', () => { step(); });
    document.getElementById('btnClear').addEventListener('click', () => {
        grid.fill(0);
        generation = 0;
        population = 0;
        document.getElementById('genCount').textContent = 0;
        document.getElementById('popCount').textContent = 0;
    });
    document.getElementById('btnRandom').addEventListener('click', randomize);

    document.getElementById('speed').addEventListener('input', (e) => {
        speed = +e.target.value;
        document.getElementById('speedVal').textContent = speed;
    });

    document.getElementById('gridSize').addEventListener('input', (e) => {
        document.getElementById('gridVal').textContent = e.target.value;
    });
    document.getElementById('gridSize').addEventListener('change', (e) => {
        resizeGrid(+e.target.value);
    });

    document.getElementById('toggleBtn').addEventListener('click', () => {
        document.getElementById('controls').classList.remove('hidden');
    });
    document.querySelector('.controls h3').addEventListener('dblclick', () => {
        document.getElementById('controls').classList.add('hidden');
    });

    window.addEventListener('resize', () => {
        const dpr = window.devicePixelRatio || 1;
        canvas.width = window.innerWidth * dpr;
        canvas.height = window.innerHeight * dpr;
        canvas.style.width = window.innerWidth + 'px';
        canvas.style.height = window.innerHeight + 'px';
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    });

    // ── Start ──
    init();
    requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
